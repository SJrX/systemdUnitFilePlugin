<p>Pass a credential to the unit. Credentials are limited-size binary or textual objects
        that may be passed to unit processes. They are primarily used for passing cryptographic keys (both
        public and private) or certificates, user account information or identity information from host to
        services. The data is accessible from the unit's processes via the file system, at a read-only
        location that (if possible and permitted) is backed by non-swappable memory. The data is only
        accessible to the user associated with the unit, via the
        <var>User=</var>/<var>DynamicUser=</var> settings (as well as the superuser). When
        available, the location of credentials is exported as the <var>$CREDENTIALS_DIRECTORY</var>
        environment variable to the unit's processes.</p>
<p>The <var>LoadCredential=</var> setting takes a textual ID to use as name for a
        credential plus a file system path, separated by a colon. The ID must be a short ASCII string
        suitable as filename in the filesystem, and may be chosen freely by the user. If the specified path
        is absolute it is opened as regular file and the credential data is read from it. If the absolute
        path refers to an AF_UNIX stream socket in the file system a connection is made
        to it (only once at unit start-up) and the credential data read from the connection, providing an
        easy IPC integration point for dynamically transferring credentials from other services.</p>
<p>If the specified path is not absolute and itself qualifies as valid credential identifier it is
        attempted to find a credential that the service manager itself received under the specified name —
        which may be used to propagate credentials from an invoking environment (e.g. a container manager
        that invoked the service manager) into a service. If no matching system credential is found, the
        directories /etc/credstore/, /run/credstore/ and
        /usr/lib/credstore/ are searched for files under the credential's name — which
        hence are recommended locations for credential data on disk. If
        <var>LoadCredentialEncrypted=</var> is used /run/credstore.encrypted/,
        /etc/credstore.encrypted/, and
        /usr/lib/credstore.encrypted/ are searched as well.</p>
<p>If the file system path is omitted it is chosen identical to the credential name, i.e. this is
        a terse way to declare credentials to inherit from the service manager into a service. This option
        may be used multiple times, each time defining an additional credential to pass to the unit.</p>
<p>If an absolute path referring to a directory is specified, every file in that directory
        (recursively) will be loaded as a separate credential. The ID for each credential will be the
        provided ID suffixed with _$FILENAME (e.g., Key_file1). When
        loading from a directory, symlinks will be ignored.</p>
<p>The contents of the file/socket may be arbitrary binary or textual data, including newline
        characters and NUL bytes.</p>
<p>The <var>LoadCredentialEncrypted=</var> setting is identical to
        <var>LoadCredential=</var>, except that the credential data is decrypted and authenticated
        before being passed on to the executed processes. Specifically, the referenced path should refer to a
        file or socket with an encrypted credential, as implemented by
        <a href="http://man7.org/linux/man-pages/man1/systemd-creds.1.html">systemd-creds(1)
    </a>. This
        credential is loaded, decrypted, authenticated and then passed to the application in plaintext form,
        in the same way a regular credential specified via <var>LoadCredential=</var> would be. A
        credential configured this way may be symmetrically encrypted/authenticated with a secret key derived
        from the system's TPM2 security chip, or with a secret key stored in
        /var/lib/systemd/credentials.secret, or with both. Using encrypted and
        authenticated credentials improves security as credentials are not stored in plaintext and only
        authenticated and decrypted into plaintext the moment a service requiring them is started. Moreover,
        credentials may be bound to the local hardware and installations, so that they cannot easily be
        analyzed offline, or be generated externally.</p>
<p>The credential files/IPC sockets must be accessible to the service manager, but don't have to
        be directly accessible to the unit's processes: the credential data is read and copied into separate,
        read-only copies for the unit that are accessible to appropriately privileged processes. This is
        particularly useful in combination with <var>DynamicUser=</var> as this way privileged data
        can be made available to processes running under a dynamic UID (i.e. not a previously known one)
        without having to open up access to all users.</p>
<p>In order to reference the path a credential may be read from within a
        <var>ExecStart=</var> command line use ${CREDENTIALS_DIRECTORY}/mycred,
        e.g. ExecStart=cat ${CREDENTIALS_DIRECTORY}/mycred. In order to reference the path
        a credential may be read from within a <var>Environment=</var> line use
        %d/mycred, e.g. Environment=MYCREDPATH=%d/mycred.</p>
<p>Currently, an accumulated credential size limit of 1 MB per unit is enforced.</p>
<p>The service manager itself may receive system credentials that can be propagated to services
        from a hosting container manager or VM hypervisor. See the <a href="https://systemd.io/CONTAINER_INTERFACE">Container Interface</a> documentation for details
        about the former. For the latter, pass <a href="https://www.dmtf.org/standards/smbios">DMI/SMBIOS</a> OEM string table entries (field type
        11) with a prefix of io.systemd.credential: or
        io.systemd.credential.binary:. In both cases a key/value pair separated by
        = is expected, in the latter case the right-hand side is Base64 decoded when
        parsed (thus permitting binary data to be passed in). Example qemu switch: -smbios
        type=11,value=io.systemd.credential:xx=yy, or -smbios
        type=11,value=io.systemd.credential.binary:rick=TmV2ZXIgR29ubmEgR2l2ZSBZb3UgVXA=. Alternatively,
        use the qemu fw_cfg node
        opt/io.systemd.credentials/. Example qemu switch: -fw_cfg
        name=opt/io.systemd.credentials/mycred,string=supersecret. They may also be specified on
        the kernel command line using the systemd.set_credential= switch (see
        <a href="http://man7.org/linux/man-pages/man1/systemd.1.html">systemd(1)
    </a>) and from
        the UEFI firmware environment via
        <a href="http://man7.org/linux/man-pages/man7/systemd-stub.7.html">systemd-stub(7)
    </a>.</p>
<p>If referencing an AF_UNIX stream socket to connect to, the connection will
        originate from an abstract namespace socket, that includes information about the unit and the
        credential ID in its socket name. Use <a href="http://man7.org/linux/man-pages/man2/getpeername.2.html">getpeername(2)
    </a>
        to query this information. The returned socket name is formatted as NUL
        RANDOM /unit/ UNIT
        / ID, i.e. a NUL byte (as required
        for abstract namespace socket names), followed by a random string (consisting of alphadecimal
        characters), followed by the literal string /unit/, followed by the requesting
        unit name, followed by the literal character /, followed by the textual credential
        ID requested. Example: \0adf9d86b6eda275e/unit/foobar.service/credx in case the
        credential credx is requested for a unit foobar.service. This
        functionality is useful for using a single listening socket to serve credentials to multiple
        consumers.</p>
<p>For further information see <a href="https://systemd.io/CREDENTIALS">System and Service
        Credentials</a> documentation.</p>
